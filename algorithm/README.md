# Algorithm

## 시간복잡도
![image](https://github.com/user-attachments/assets/a233da95-9928-4897-ac25-8319cb77879d)

시간 복잡도(Time Complexity)는 알고리즘의 효율성을 평가하는 중요한 척도입니다. 이는 알고리즘이 입력 크기(n)에 따라 얼마나 많은 시간(연산 횟수)이 필요한지를 나타냅니다. 시간 복잡도는 주로 빅오 표기법(Big O Notation)을 사용하여 표현하며, 입력 크기가 증가할 때 알고리즘의 성능이 어떻게 변하는지를 나타냅니다.

### **1. 시간 복잡도의 개념**

- **시간 복잡도**는 알고리즘이 실행되는데 걸리는 시간의 상한선을 나타냅니다. 이는 알고리즘의 성능을 평가할 때, 최악의 경우를 고려하여 얼마나 시간이 걸릴지를 측정합니다.
- **빅오 표기법**: 시간 복잡도는 일반적으로 O(f(n)) 형식으로 표현됩니다. 여기서 f(n)은 입력 크기 n에 대한 함수이며, n이 커질수록 알고리즘의 성능이 어떻게 변화하는지를 나타냅니다.

### **2. 빅오 표기법(Big O Notation)**

- **O(1) - 상수 시간 복잡도**:
  - 입력 크기에 상관없이 알고리즘이 일정한 시간 내에 실행됩니다.
  - 예: 배열의 첫 번째 요소를 읽는 연산.

- **O(log n) - 로그 시간 복잡도**:
  - 입력 크기가 증가함에 따라 실행 시간이 매우 느리게 증가합니다. 보통 이진 탐색 알고리즘에서 나타납니다.
  - 예: 이진 탐색(Binary Search).

- **O(n) - 선형 시간 복잡도**:
  - 입력 크기에 비례하여 실행 시간이 증가합니다. 리스트에서 특정 값을 찾는 경우가 여기에 해당합니다.
  - 예: 배열의 모든 요소를 합산하는 연산.

- **O(n log n) - 선형 로그 시간 복잡도**:
  - 입력 크기에 로그를 곱한 시간만큼 실행 시간이 증가합니다. 효율적인 정렬 알고리즘에서 주로 나타납니다.
  - 예: 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort).

- **O(n^2) - 이차 시간 복잡도**:
  - 입력 크기의 제곱에 비례하여 실행 시간이 증가합니다. 중첩된 반복문이 있는 알고리즘에서 흔히 나타납니다.
  - 예: 버블 정렬(Bubble Sort), 선택 정렬(Selection Sort).

- **O(2^n) - 지수 시간 복잡도**:
  - 입력 크기에 대해 지수적으로 실행 시간이 증가합니다. 주로 비효율적인 재귀 알고리즘에서 나타납니다.
  - 예: 피보나치 수열을 재귀적으로 계산하는 알고리즘.

- **O(n!) - 팩토리얼 시간 복잡도**:
  - 입력 크기에 대해 팩토리얼(n!)만큼 실행 시간이 증가합니다. 주로 순열과 조합과 같은 매우 복잡한 문제에서 나타납니다.
  - 예: 순열을 생성하는 알고리즘.

### **3. 시간 복잡도와 알고리즘 문제 예시**

#### **문제 1: 배열에서 최대값 찾기**

**문제**: 정수 배열이 주어졌을 때, 배열에서 최대값을 찾는 알고리즘을 작성하시오.

```python
def find_max(arr):
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val
```

- **시간 복잡도 분석**:
  - 이 알고리즘은 배열의 모든 요소를 한 번씩 검사합니다. 배열의 길이가 n일 때, 최대값을 찾기 위해 n번의 비교가 필요합니다.
  - **시간 복잡도**: O(n) - 선형 시간 복잡도.

#### **문제 2: 이진 탐색(Binary Search)**

**문제**: 정렬된 정수 배열이 주어졌을 때, 특정 값이 배열에 있는지 찾는 이진 탐색 알고리즘을 작성하시오.

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    
    return -1
```

- **시간 복잡도 분석**:
  - 이진 탐색은 배열을 절반씩 나누어 탐색합니다. 매 단계마다 탐색 범위가 절반으로 줄어듭니다.
  - 배열의 길이가 n일 때, 최악의 경우에도 탐색 횟수는 log n번입니다.
  - **시간 복잡도**: O(log n) - 로그 시간 복잡도.

#### **문제 3: 병합 정렬(Merge Sort)**

**문제**: 정수 배열을 오름차순으로 정렬하는 병합 정렬 알고리즘을 작성하시오.

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

- **시간 복잡도 분석**:
  - 병합 정렬은 배열을 반으로 나누고, 각각을 정렬한 후 병합하는 과정을 반복합니다. 배열을 나누는 데 log n 단계가 필요하고, 각 단계에서 n번의 병합 연산이 필요합니다.
  - **시간 복잡도**: O(n log n) - 선형 로그 시간 복잡도.

#### **문제 4: 피보나치 수열 계산(비효율적 재귀)**

**문제**: 피보나치 수열의 n번째 수를 계산하는 알고리즘을 재귀적으로 작성하시오.

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

- **시간 복잡도 분석**:
  - 이 알고리즘은 피보나치 수열의 각 항목을 구하기 위해 두 번의 재귀 호출을 합니다. 따라서 동일한 계산이 여러 번 반복되어 비효율적입니다.
  - **시간 복잡도**: O(2^n) - 지수 시간 복잡도.
  - 이 문제는 동적 프로그래밍을 사용하면 효율적으로 개선할 수 있습니다.

### **4. 시간 복잡도 비교**

시간 복잡도를 알고리즘 문제와 결부시켜 설명하면, 각 알고리즘이 얼마나 효율적인지 명확히 이해할 수 있습니다. 

- **O(1)**: 배열의 첫 번째 요소 접근.
- **O(log n)**: 이진 탐색.
- **O(n)**: 배열의 최대값 찾기.
- **O(n log n)**: 병합 정렬, 퀵 정렬.
- **O(n^2)**: 버블 정렬, 선택 정렬.
- **O(2^n)**: 비효율적인 피보나치 수열 계산.


<br>
<br>
