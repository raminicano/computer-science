# network를 위한 레포

- [통신에 대한 이해](#통신에-대한-이해)
- [소켓 통신과 HTTP 통신의 차이](#소켓-통신과-http-통신의-차이)
- [API 연결 시 요소들의 순서](#API-연결-시-요소들의-순서)
- [정적 서버와 동적 서버의 차이](#정적-서버와-동적-서버의-차이)
- [www.google.com을 누를 때 발생하는 일련의 과정](#www.google.com을-누를-때-발생하는-일련의-과정)
- [OSI 7계층](#OSI-7계층)
- [HTTP란 무엇인가?](#HTTP란-무엇인가?)
- [HTTP 상태코드](#HTTP-상태코드)
- [TCP/IP](#TCP/IP)
- [gRPC와 REST API](#gRPC와-REST-API)


## 통신에 대한 이해

통신(Communication)은 정보를 송신자와 수신자 사이에서 교환하는 과정을 의미합니다. 컴퓨터 과학에서는 통신이 주로 컴퓨터, 서버, 네트워크 장치 간에 데이터 패킷이나 메시지를 주고받는 방식으로 이루어집니다. 이 과정은 물리적 매체(예: 케이블, 무선)와 프로토콜(규약)을 통해 수행됩니다.

- **송신자(Sender)**: 정보를 보내는 쪽입니다. 컴퓨터 네트워크에서는 주로 클라이언트 또는 서버 역할을 합니다.
- **수신자(Receiver)**: 정보를 받는 쪽입니다. 송신자가 보낸 데이터를 수신하여 처리합니다.
- **메시지(Message)**: 송신자가 수신자에게 보내는 정보나 데이터입니다.
- **프로토콜(Protocol)**: 통신 규약을 의미하며, 데이터를 송수신하는 과정에서 지켜야 할 규칙이나 절차를 정의합니다. 예를 들어, HTTP, TCP, UDP 등이 있습니다.
- **전송 매체(Transmission Medium)**: 정보를 송수신하는 데 사용되는 물리적 또는 논리적 경로입니다. 예를 들어, 네트워크 케이블, 광섬유, 무선 신호 등이 있습니다.

<br>
<br>


## 소켓 통신과 HTTP 통신의 차이

**소켓 통신(Socket Communication):**
- **개념**: 소켓 통신은 네트워크에서 두 장치 간에 데이터 전송을 가능하게 하는 양방향 통신 채널입니다. 소켓은 네트워크 연결의 종단점(Endpoint)으로, IP 주소와 포트 번호로 식별됩니다.
- **기본 원리**: 소켓은 OSI 모델의 전송 계층(주로 TCP 또는 UDP)을 사용하여 직접적인 통신을 수행합니다. 이는 애플리케이션이 데이터를 전송할 때 소켓을 열고, 그 소켓을 통해 데이터를 보내거나 받는 방식입니다.
- **특징**:
  - **양방향 통신**: 클라이언트와 서버는 데이터를 자유롭게 주고받을 수 있습니다.
  - **지속적인 연결**: 연결이 유지되는 동안 데이터 전송이 가능합니다. (주로 TCP 소켓이 이러한 지속적인 연결을 제공)
  - **프로토콜 독립적**: 소켓은 특정 프로토콜에 종속되지 않으며, TCP, UDP 등 다양한 프로토콜에서 사용할 수 있습니다.
  - **저수준 통신**: 개발자가 통신의 세부 사항(예: 패킷 전송, 재전송 등)을 직접 제어할 수 있습니다.

**HTTP 통신 (HyperText Transfer Protocol):**
- **개념**: HTTP는 월드 와이드 웹(WWW)에서 데이터를 주고받기 위한 프로토콜입니다. HTTP는 주로 웹 브라우저와 웹 서버 간의 통신에 사용되며, 텍스트 기반의 요청/응답 구조로 동작합니다.
- **기본 원리**: HTTP는 애플리케이션 계층의 프로토콜로, 클라이언트(예: 웹 브라우저)가 서버에 요청(request)을 보내고, 서버는 그에 대한 응답(response)을 반환하는 방식으로 작동합니다.
- **특징**:
  - **비연결성(Connectionless)**: HTTP는 요청-응답이 완료되면 연결을 끊습니다. 따라서 매 요청마다 새로운 연결이 이루어집니다. (HTTP/1.x의 경우)
  - **상태 비저장(Stateless)**: 서버는 요청 간에 클라이언트의 상태를 유지하지 않습니다. 즉, 각각의 요청은 독립적으로 처리됩니다.
  - **텍스트 기반 프로토콜**: HTTP는 텍스트 형식으로 요청과 응답을 주고받으며, 그 내용은 쉽게 읽을 수 있습니다.
  - **프로토콜 고수준**: 개발자는 HTTP 요청과 응답의 구조만 이해하면 되며, 저수준 네트워크 통신에 대해 신경 쓸 필요가 없습니다.

**소켓 통신과 HTTP 통신의 차이점 요약**

- **사용 계층**: 소켓 통신은 전송 계층(TCP, UDP)에서 작동하며, HTTP는 애플리케이션 계층에서 작동합니다.
- **통신 방식**: 소켓 통신은 양방향, 지속적인 연결이 가능하며, HTTP 통신은 요청-응답 모델에 따라 비연결성으로 동작합니다.
- **복잡성**: 소켓 통신은 저수준 통신으로 개발자가 직접적인 통제와 세부 조정이 가능하지만, 더 복잡할 수 있습니다. HTTP는 고수준 프로토콜로, 사용이 상대적으로 간단합니다.
- **프로토콜 독립성**: 소켓 통신은 TCP, UDP 등 다양한 프로토콜에서 사용할 수 있는 반면, HTTP는 웹 통신에 특화된 프로토콜입니다.


<br>
<br>


## API 연결 시 요소들의 순서

API : Application Programming Interface 는 다양한 애플리케이션 간의 상호작용 가능하게 하는 인터페이스이다.

1. **클라이언트 요청**:
   - 클라이언트(예: 웹 브라우저, 모바일 앱)는 서버에 데이터를 요청하거나 특정 작업을 수행하기 위해 API 호출을 시작합니다. 이 요청은 주로 HTTP(S) 프로토콜을 사용하며, GET, POST, PUT, DELETE 등의 메서드로 이루어집니다.

2. **요청 처리**:
   - **API 게이트웨이**(선택 사항): 요청이 API 게이트웨이를 통해 전달될 수 있습니다. API 게이트웨이는 여러 API 서비스로의 요청을 관리하고 라우팅하는 역할을 합니다.
   - **서버**: 요청이 웹 서버나 애플리케이션 서버에 도달하면, 해당 요청을 처리할 서비스나 컨트롤러로 전달됩니다.

3. **비즈니스 로직 처리**:
   - 서버에서는 클라이언트의 요청을 처리하는 비즈니스 로직이 실행됩니다. 이 단계에서 필요한 데이터 조작, 계산, 외부 API 호출 등이 이루어집니다.

4. **데이터베이스 연동**:
   - 비즈니스 로직에서 데이터가 필요할 경우, 서버는 데이터베이스와 상호작용하여 데이터를 읽거나 수정합니다.

5. **응답 생성**:
   - 서버는 요청에 대한 응답을 생성하고, JSON, XML 등의 포맷으로 데이터를 포장합니다.

6. **응답 반환**:
   - 서버는 생성된 응답을 클라이언트에 반환합니다. 클라이언트는 이 데이터를 처리하여 사용자에게 보여줍니다.

<br>
<br>


## 정적 서버와 동적 서버의 차이

**정적 서버 (Static Server):**
- **기능**: 정적 서버는 변경되지 않는 콘텐츠(정적 콘텐츠)를 제공합니다. 정적 콘텐츠에는 HTML, CSS, JavaScript 파일, 이미지, 비디오 등이 포함됩니다.
- **작동 방식**: 정적 서버는 클라이언트 요청이 있을 때 미리 저장된 파일을 그대로 반환합니다. 서버는 파일을 불러오는 것 외에 추가적인 처리를 하지 않습니다.
- **장점**:
  - 빠른 응답 시간: 파일을 그대로 반환하기 때문에 처리가 매우 빠릅니다.
  - 간단한 설정: 서버 설정이 간단하며, 리소스가 적게 필요합니다.
- **단점**:
  - 콘텐츠 변경 불가: 서버에서 제공하는 콘텐츠가 고정되어 있으며, 동적으로 변경할 수 없습니다.

**동적 서버 (Dynamic Server):**
- **기능**: 동적 서버는 클라이언트의 요청에 따라 실시간으로 콘텐츠를 생성하여 제공합니다. 웹 애플리케이션에서 흔히 사용하는 서버입니다.
- **작동 방식**: 요청이 들어오면 서버는 비즈니스 로직을 수행하고, 데이터베이스와 상호작용하여 필요한 데이터를 불러옵니다. 그런 다음, 데이터를 기반으로 HTML 또는 JSON 같은 응답을 생성하여 클라이언트에 반환합니다.
- **장점**:
  - 유연성: 사용자 입력에 따라 콘텐츠를 동적으로 생성할 수 있습니다.
  - 데이터 통합: 데이터베이스와의 연동을 통해 실시간 데이터를 제공할 수 있습니다.
- **단점**:
  - 느린 응답 시간: 서버가 실시간으로 데이터를 처리하고 응답을 생성해야 하므로, 정적 서버에 비해 응답 시간이 느릴 수 있습니다.
  - 복잡한 설정: 동적 서버는 더 많은 자원과 설정이 필요합니다.

<br>
<br>


## www.google.com을 누를 때 발생하는 일련의 과정
![image](https://github.com/user-attachments/assets/5080af1a-4819-4ebb-a0dd-71af78a2e6b8)


### **1. www.google.com을 누를 때 발생하는 현상**

브라우저 주소창에 `www.google.com`을 입력하고 Enter를 누르면, 사용자가 요청한 웹 페이지를 브라우저가 불러오기 위해 다양한 작업이 수 행됩니다. 이 과정은 여러 단계로 나누어 설명할 수 있으며, OSI 7계층 모델을 활용하여 각 단계를 이해할 수 있습니다.

#### **단계별 과정**:

1. **브라우저에서의 초기 작업 (응용 계층, OSI 7계층 중 7계층)**:
   - 사용자가 `www.google.com`을 입력하고 Enter를 누르면, 브라우저는 HTTP/HTTPS 요청을 준비합니다. HTTP는 OSI 7계층의 **응용 계층**에서 작동하는 프로토콜입니다.
   - 브라우저는 먼저 캐시된 DNS 정보를 확인하여 IP 주소를 찾습니다. 캐시된 DNS 정보가 없다면, DNS 서버에 쿼리를 보내 IP 주소를 요청합니다.

2. **DNS 요청 (응용 계층, 7계층)**:
   - DNS(도메인 네임 시스템)는 도메인 이름을 IP 주소로 변환하는 서비스입니다. DNS 요청은 브라우저에서 로컬 DNS 서버로 전송됩니다.
   - 로컬 DNS 서버가 해당 도메인의 IP 주소를 알고 있다면 이를 반환하고, 모를 경우 DNS 트리 구조를 따라 상위 DNS 서버에 질의하여 IP 주소를 찾습니다.

3. **TCP 연결 설정 (전송 계층, OSI 7계층 중 4계층)**:
   - IP 주소를 획득한 후, 브라우저는 서버와 TCP 연결을 설정합니다. TCP는 OSI 4계층(전송 계층)에서 작동하며, 3-way handshake(3방향 핸드셰이크)를 통해 연결이 설정됩니다.
     - **3-way handshake**:
       1. 클라이언트가 서버에 SYN 패킷을 전송합니다.
       2. 서버는 클라이언트에게 SYN-ACK 패킷으로 응답합니다.
       3. 클라이언트는 ACK 패킷을 서버에 전송하여 연결이 확립됩니다.

4. **데이터 전송 및 응답 (네트워크, 데이터 링크, 물리 계층, OSI 3, 2, 1계층)**:
   - TCP 연결이 설정되면, 브라우저는 HTTP 요청을 보냅니다. 이 요청은 전송 계층에서 TCP 세그먼트로, 네트워크 계층(OSI 3계층)에서 IP 패킷으로, 데이터 링크 계층(OSI 2계층)에서 프레임으로 인캡슐레이션됩니다.
   - 물리 계층(OSI 1계층)을 통해 실제 네트워크를 통해 구글 서버로 전송됩니다.
   - 구글 서버는 요청을 처리한 후, 브라우저에 HTTP 응답을 전송합니다. 이 응답은 웹 페이지 데이터, CSS, JavaScript 파일 등을 포함할 수 있습니다.

5. **브라우저에 페이지 렌더링 (응용 계층, 7계층)**:
   - 브라우저는 수신한 HTML 문서를 해석하고, 추가로 필요한 리소스(CSS, 이미지, JavaScript 등)를 다시 요청하여 화면에 페이지를 렌더링합니다.

### **2. 어느 홉에서 지연이 되는지 확인하는 방법**

네트워크 요청이 여러 라우터(홉)을 거치면서 목적지에 도달합니다. 네트워크 지연이 발생하면 어느 구간에서 문제가 생겼는지 확인해야 합니다.

- **traceroute** 명령어:
  - `traceroute`(Unix/Linux) 또는 `tracert`(Windows) 명령어를 사용하여 네트워크 경로 상의 각 홉을 확인할 수 있습니다. 이 명령어는 패킷이 각 홉을 지날 때마다 RTT(Round-Trip Time)를 기록하여, 어느 구간에서 지연이 발생하는지 보여줍니다.

  ```bash
  tracert www.google.com
  ```

- **RTT 분석**:
  - 각 홉의 RTT를 분석하여, 어느 홉에서 지연이 발생하는지 확인합니다. 지연이 특정 구간에서만 발생한다면, 그 구간에 있는 네트워크 장비나 라우터에 문제가 있을 가능성이 큽니다.
  - 지연이 국내에서 발생하면 한국 쪽 네트워크 문제가 될 수 있으며, 해외에서는 해당 국가나 구글 서버 쪽 네트워크 문제일 가능성이 있습니다.

### **3. DNS의 역할 및 nslookup 사용**

DNS는 도메인 이름을 IP 주소로 변환해주는 중요한 역할을 합니다.

- **DNS가 하는 일**:
  - 예를 들어 `www.google.com`을 IP 주소로 변환해주는 것이 DNS의 역할입니다. 사용자가 브라우저에 도메인을 입력하면, DNS 서버는 이 도메인의 IP 주소를 반환하여, 브라우저가 해당 서버와 통신할 수 있도록 합니다.

- **nslookup 사용 방법**:
  - `nslookup` 명령어를 사용하면 도메인의 IP 주소를 직접 조회할 수 있습니다. 이를 통해 특정 도메인이 어느 IP 주소와 연결되어 있는지 확인할 수 있습니다.

  ```bash
  nslookup www.google.com
  ```

  - 명령어를 입력하면 해당 도메인의 IP 주소가 출력됩니다. 이를 통해 DNS 서버가 올바르게 동작하는지 확인할 수 있습니다.

### **4. 요약**

- **www.google.com을 입력하면**: 브라우저는 DNS를 통해 IP 주소를 찾고, TCP 연결을 설정한 후 HTTP 요청을 보내고, 응답을 받아 렌더링합니다. 이 과정은 OSI 7계층의 모든 계층을 거칩니다.
- **네트워크 지연 문제**는 `traceroute` 명령어로 각 홉에서의 지연을 확인하여 진단할 수 있습니다.
- **DNS**는 도메인 이름을 IP 주소로 변환하며, `nslookup` 명령어로 DNS 질의 결과를 확인할 수 있습니다.

<br>
<br>

## **OSI 7계층**
![image](https://github.com/user-attachments/assets/cf20729d-7dad-4673-84d9-acb3d4a20902)

### 설명

#### **1. 물리 계층 (Physical Layer, 1계층)**

- **역할**: 물리 계층은 데이터를 전기 신호, 광 신호, 무선 신호 등으로 변환하여 물리적인 매체(예: 케이블, 무선)에서 전송하는 역할을 합니다. 이 계층에서는 실제로 데이터를 전송하는 하드웨어적인 부분을 다룹니다.
- **전송되는 데이터**: 비트(Bit)
- **단위**: 비트(bit)

#### **2. 데이터 링크 계층 (Data Link Layer, 2계층)**

- **역할**: 데이터 링크 계층은 물리 계층에서 발생할 수 있는 오류를 감지하고 수정하며, 데이터가 네트워크를 통해 제대로 전송되도록 보장합니다. 이 계층에서는 프레임 단위로 데이터가 전송되며, MAC 주소를 사용하여 네트워크 내에서의 장치 간 통신을 담당합니다.
- **전송되는 데이터**: 프레임(Frame)
- **단위**: 프레임(Frame)


#### **3. 네트워크 계층 (Network Layer, 3계층)**

- **역할**: 네트워크 계층은 데이터가 출발지에서 목적지까지 가장 효율적으로 전달되도록 경로를 설정하는 역할을 합니다. 이 계층에서는 라우팅이 주요 기능이며, 패킷 단위로 데이터를 전송합니다. IP 주소를 사용하여 네트워크 간의 장치 식별 및 통신을 담당합니다.
- **전송되는 데이터**: 패킷(Packet)
- **단위**: 패킷(Packet)


#### **4. 전송 계층 (Transport Layer, 4계층)**

- **역할**: 전송 계층은 데이터의 정확한 전송을 보장하는 계층으로, 신뢰성 있는 통신을 위해 데이터 세그먼트를 관리합니다. 이 계층에서는 데이터의 흐름 제어, 오류 제어, 재전송, 포트 번호를 통한 응용 프로그램 간의 통신 관리 등을 담당합니다.
- **전송되는 데이터**: 세그먼트(Segment, TCP) 또는 데이터그램(Datagram, UDP)
- **단위**: 세그먼트(Segment) / 데이터그램(Datagram)

  ![image](https://github.com/user-attachments/assets/2b3261a7-71f0-46fc-b615-a5587cea7fc5)
- TCP의 경우 3 Way-Handshake라는 방식으로 통신합니다. 장치간에 연결이 잘 되었는를 3번의 과정을 통해 확인하여 데이터 전송의 신뢰성을 확보합니다.
- SYN은 synchronize sequence numbers의 약자이고 ACK는 acknowledgements의 약자입니다.
  
  상태	설명
  CLOSED	닫힌 상태
  LISTEN	요청 대기 상태
  SYN-SENT	SYN 요청 상태
  SYN-RECEIVED	SYN 요청을 받은 상태
  ESTABLISHED	연결 확인 상태

(1) 클라이언트가 서버에게 SYN을 요청하고 SYN-SENT 상태가 됩니다.

(2) SYN을 요청받은 서버는 SYN-RECEIVED 상태가 되고, SYN과 함께 ACK를 클라이언트에게 읍답합니다.

(3) SYN+ACK를 응답받은 클라이언트는 ACK를 서버에 요청하고 클라이언트와 서버는 ESTABLISHED 상태가 됩니다.

쉽게 말해서 클라이언트가 “내말 들려?” 라고 요청을 보내면 서버가 “응 들려, 넌 내말 들려?” 라고 응답하고, 클라이언트가 “응, 나도 들려” 라고 대답하면서 대화가 시작되는겁니다.

#### **5. 세션 계층 (Session Layer, 5계층)**

- **역할**: 세션 계층은 응용 프로그램 간의 세션(대화)을 설정, 유지, 종료하는 역할을 합니다. 이 계층에서는 세션 복구 기능과 통신의 동기화를 관리하여 데이터가 손실되지 않도록 보장합니다.
- **전송되는 데이터**: 데이터(Data)
- **단위**: 데이터(Data)


#### **6. 표현 계층 (Presentation Layer, 6계층)**

- **역할**: 표현 계층은 데이터의 표현 형식을 관리하는 계층으로, 응용 프로그램들이 데이터를 이해할 수 있도록 변환합니다. 이 계층에서는 데이터 인코딩, 디코딩, 암호화, 복호화, 압축 등을 처리합니다.
- **전송되는 데이터**: 데이터(Data)
- **단위**: 데이터(Data)


#### **7. 응용 계층 (Application Layer, 7계층)**

- **역할**: 응용 계층은 최종 사용자가 네트워크 서비스와 상호작용할 수 있도록 지원하는 계층입니다. 웹 브라우저, 이메일 클라이언트, 파일 전송 프로그램 등과 같은 애플리케이션이 이 계층에서 동작하며, 프로토콜을 통해 네트워크와 상호작용합니다.
- **전송되는 데이터**: 데이터(Data)
- **단위**: 데이터(Data)


### **데이터 단위와 전송 크기**

OSI 모델의 각 계층은 서로 다른 데이터 단위를 사용하여 데이터를 송수신합니다. 이러한 데이터 단위는 계층별로 다르며, 아래와 같은 계층별 데이터 단위를 사용합니다.

1. **물리 계층**: 비트(Bit)
   - **단위**: 비트는 1과 0으로 이루어진 데이터의 최소 단위입니다. 전기적 신호, 광신호, 무선 신호 등으로 전달됩니다.

2. **데이터 링크 계층**: 프레임(Frame)
   - **단위**: 프레임은 MAC 주소와 오류 검출 비트를 포함하는 패킷의 데이터 링크 계층 단위입니다.

3. **네트워크 계층**: 패킷(Packet)
   - **단위**: 패킷은 네트워크 계층에서 데이터를 전송하기 위한 단위입니다. 패킷은 출발지와 목적지 IP 주소, 패킷 번호 등을 포함합니다.

4. **전송 계층**: 세그먼트(Segment) 또는 데이터그램(Datagram)
   - **단위**: 세그먼트는 TCP를 사용하는 경우 전송되는 데이터 단위입니다. UDP를 사용하는 경우 데이터그램이라 부릅니다.

5. **세션, 표현, 응용 계층**: 데이터(Data)
   - **단위**: 데이터는 이 세 계층에서 처리되는 정보로, 실제로 전송되는 최종 데이터의 형태를 의미합니다.

### **프로토콜과 전송 크기**

전송 크기는 사용되는 프로토콜과 데이터의 유형에 따라 크게 달라집니다.
- **이더넷 프레임**: 최대 전송 유닛(MTU)은 보통 1500바이트입니다.
- **TCP 세그먼트**: TCP 헤더와 데이터를 포함한 세그먼트는 패킷 단위로 쪼개져서 전송됩니다. TCP/IP 헤더는 일반적으로 20바이트에서 60바이트 사이입니다.
- **HTTP 패킷**: 실제 웹 페이지의 크기와 그에 따른 자원(JS, CSS, 이미지 등)에 따라 크기가 결정됩니다. 작은 HTTP 요청은 수백 바이트, 대형 데이터 파일은 수십 메가바이트까지 커질 수 있습니다.

### 프로토콜과 관련 장비

| OSI 계층          | 주요 프로토콜                              | 관련 장비                           |
|-------------------|-------------------------------------------|-------------------------------------|
| **7. 응용 계층** (Application Layer)    | HTTP, HTTPS, FTP, SMTP, IMAP, POP3, DNS, Telnet | 애플리케이션 소프트웨어 (웹 브라우저, 이메일 클라이언트 등) |
| **6. 표현 계층** (Presentation Layer)  | SSL/TLS, JPEG, GIF, PNG, MPEG, ASCII, EBCDIC | 데이터 변환 장치 (암호화 장비)        |
| **5. 세션 계층** (Session Layer)        | RPC, NetBIOS, PPTP, SOCKS               | 게이트웨이, 방화벽                   |
| **4. 전송 계층** (Transport Layer)      | TCP, UDP, SCTP, SSL/TLS                | 방화벽, 로드 밸런서                  |
| **3. 네트워크 계층** (Network Layer)    | IP, ICMP, ARP, RIP, OSPF, BGP          | 라우터, L3 스위치                   |
| **2. 데이터 링크 계층** (Data Link Layer) | Ethernet, PPP, HDLC, Frame Relay       | 스위치, 브리지, 무선 액세스 포인트    |
| **1. 물리 계층** (Physical Layer)       | Ethernet (IEEE 802.3), Wi-Fi (IEEE 802.11), Bluetooth, USB | 허브, 리피터, 케이블, 무선 장비        |

<br>
<br>



## **HTTP란 무엇인가?**
HTTP(하이퍼텍스트 전송 프로토콜, Hypertext Transfer Protocol)는 웹에서 데이터를 주고받기 위한 가장 기본적인 프로토콜입니다. HTTP는 웹 브라우저(클라이언트)와 웹 서버 간의 통신을 정의하며, 인터넷 상에서 하이퍼텍스트 문서(HTML)를 교환하기 위한 표준입니다.

- **HTTP의 개념**:
  - HTTP는 클라이언트와 서버 간의 요청(Request)과 응답(Response) 구조로 이루어져 있습니다. 클라이언트는 서버에 요청을 보내고, 서버는 해당 요청에 대한 응답을 반환합니다.
  - HTTP는 상태를 유지하지 않는 비연결성 프로토콜(Stateless Protocol)로, 각 요청은 독립적으로 처리됩니다.

- **OSI 모델에서 HTTP의 위치**:
  - HTTP는 **OSI 7계층** 중에서 **응용 계층**(Application Layer, 7계층)에 속합니다. 이 계층은 사용자가 직접적으로 상호작용하는 애플리케이션과 관련된 프로토콜을 포함합니다. HTTP는 웹 페이지를 요청하고 전송하는 데 사용됩니다.

### **1. HTTP/1.1의 특징**

- **HTTP/1.1**:
  - **보내고 받고만 가능함**: HTTP/1.1에서는 클라이언트가 요청을 보내면, 서버가 해당 요청에 대한 응답을 완료한 후에야 클라이언트가 다음 요청을 보낼 수 있습니다. 이를 **직렬화된 요청-응답 모델**이라고 합니다.
  - **Persistent Connection**: HTTP/1.1에서는 하나의 TCP 연결을 통해 여러 개의 HTTP 요청과 응답을 처리할 수 있는 지속 연결(Persistent Connection)을 도입했습니다. 이로 인해 TCP 연결이 자주 열리고 닫히는 것을 방지하여 성능을 개선했습니다.
  - **Head-of-Line Blocking**: HTTP/1.1에서는 요청이 순차적으로 처리되기 때문에, 첫 번째 요청이 완료되기 전까지 두 번째 요청을 처리할 수 없습니다. 이를 "Head-of-Line Blocking" 문제라고 하며, 성능 저하의 원인이 될 수 있습니다.

### **2. HTTP/2.0의 특징**

- **HTTP/2.0**:
  - **보내고 보내고가 가능함**: HTTP/2.0에서는 **멀티플렉싱(Multiplexing)**을 도입하여, 하나의 연결에서 여러 요청과 응답을 동시에 주고받을 수 있습니다. 이로 인해 한 요청이 완료되기를 기다리지 않고도 다른 요청을 병렬로 처리할 수 있습니다.
  - **헤더 압축**: HTTP/2.0에서는 헤더 정보를 효율적으로 전송하기 위해 헤더 압축을 사용합니다. 이를 통해 네트워크 대역폭을 절약하고 응답 시간을 줄일 수 있습니다.
  - **서버 푸시**: HTTP/2.0에서는 서버가 클라이언트의 요청 없이도 클라이언트가 필요로 할 리소스를 미리 전송할 수 있는 서버 푸시(Server Push) 기능을 제공합니다. 이 기능은 웹 페이지 로딩 속도를 향상시키는 데 유용합니다.

### **3. HTTP/3.0과 QUIC**

- **HTTP/3.0**:
  - HTTP/3.0은 전송 계층 프로토콜로 **TCP 대신 QUIC**(Quick UDP Internet Connections)을 사용합니다. QUIC은 UDP를 기반으로 설계된 전송 계층 프로토콜로, HTTP/2.0의 단점(예: TCP의 Head-of-Line Blocking 문제)을 해결합니다.
  
- **TCP와 UDP**:
  - **TCP (Transmission Control Protocol)**:
    - **3-way handshake**: TCP는 연결형 프로토콜로, 신뢰성 있는 데이터 전송을 위해 3-way handshake(3방향 핸드셰이크)를 통해 연결을 설정합니다.
    - **데이터 전송의 신뢰성**: TCP는 데이터의 순서와 무결성을 보장합니다. 만약 패킷이 손실되면 재전송을 통해 패킷을 복구합니다.
  
  - **UDP (User Datagram Protocol)**:
    - **연결 없는 전송**: UDP는 비연결형 프로토콜로, 데이터를 빠르게 전송하지만, 데이터의 순서나 무결성은 보장하지 않습니다. 즉, 데이터를 받았는지 여부를 확인하지 않고 전송합니다.
    - **빠른 전송**: UDP는 TCP보다 빠르지만, 신뢰성이 낮습니다. 따라서 실시간 스트리밍, 온라인 게임, DNS 조회와 같은 시간에 민감한 애플리케이션에서 주로 사용됩니다.

- **QUIC**:
  - QUIC은 UDP를 기반으로 TCP의 장점(신뢰성)과 UDP의 장점(빠른 전송 속도)을 결합한 프로토콜입니다. HTTP/3.0에서 사용되며, TLS를 기본적으로 통합하여 보안성을 유지하면서도 빠르게 데이터를 전송합니다.
  - **연결 손실에 대한 복원력**: QUIC은 연결이 일시적으로 끊어져도 빠르게 복구할 수 있으며, 다중 스트림을 통해 한 스트림에서 문제가 발생해도 다른 스트림에 영향을 주지 않습니다.


<br>
<br>

## HTTP 상태코드

https://www.django-rest-framework.org/api-guide/status-codes/

정보(1xx), 성공(2xx), 리다이렉션(3xx), 클라이언트 오류(4xx), 서버 오류(5xx).

| **상태 코드** | **범주**       | **의미**                                          | **설명**                                                                 |
|---------------|----------------|--------------------------------------------------|--------------------------------------------------------------------------|
| **200**       | 성공(2xx)      | OK                                               | 요청이 성공적으로 처리되었음을 의미합니다. 클라이언트가 요청한 리소스가 정상적으로 반환됩니다. |
| **201**       | 성공(2xx)      | Created                                          | 요청이 성공적이었으며, 서버가 새로운 리소스를 생성했음을 의미합니다.                                          |
| **204**       | 성공(2xx)      | No Content                                       | 요청이 성공적으로 처리되었으나, 반환할 콘텐츠가 없음을 의미합니다.                                          |
| **301**       | 리다이렉션(3xx) | Moved Permanently                                | 요청한 리소스가 영구적으로 새로운 URL로 이동했음을 의미합니다. 새로운 URL로의 리다이렉션이 필요합니다.       |
| **302**       | 리다이렉션(3xx) | Found                                            | 요청한 리소스가 일시적으로 다른 URL에 있음을 의미합니다. 클라이언트는 이후에 원래의 URL을 사용할 수 있습니다.  |
| **304**       | 리다이렉션(3xx) | Not Modified                                     | 클라이언트의 캐시된 버전이 최신 버전이므로, 다시 전송할 필요가 없음을 의미합니다.                            |
| **400**       | 클라이언트 오류(4xx) | Bad Request                                      | 클라이언트의 요청이 잘못되었음을 의미합니다. 잘못된 구문, 유효하지 않은 요청 매개변수 등이 원인이 될 수 있습니다. |
| **401**       | 클라이언트 오류(4xx) | Unauthorized                                     | 인증이 필요하지만, 클라이언트가 인증되지 않았음을 의미합니다. 보통 WWW-Authenticate 헤더와 함께 전송됩니다. |
| **403**       | 클라이언트 오류(4xx) | Forbidden                                        | 클라이언트가 요청한 리소스에 접근할 권한이 없음을 의미합니다.                                             |
| **404**       | 클라이언트 오류(4xx) | Not Found                                        | 요청한 리소스를 찾을 수 없음을 의미합니다. URL이 잘못되었거나, 리소스가 삭제된 경우에 발생합니다.              |
| **405**       | 클라이언트 오류(4xx) | Method Not Allowed                               | 요청한 HTTP 메서드가 서버에서 허용되지 않음을 의미합니다. 예: GET 메서드만 허용된 엔드포인트에 POST 요청       |
| **409**       | 클라이언트 오류(4xx) | Conflict                                         | 요청이 현재 서버 상태와 충돌함을 의미합니다. 예: 리소스 생성 중 중복 데이터 발생                             |
| **500**       | 서버 오류(5xx)   | Internal Server Error                            | 서버에서 요청을 처리하는 동안 오류가 발생했음을 의미합니다. 일반적인 서버 오류 코드입니다.                   |
| **502**       | 서버 오류(5xx)   | Bad Gateway                                      | 서버가 게이트웨이로 동작할 때, 상위 서버로부터 잘못된 응답을 받았음을 의미합니다.                          |
| **503**       | 서버 오류(5xx)   | Service Unavailable                              | 서버가 과부하 상태이거나 유지보수 중이어서 요청을 처리할 수 없음을 의미합니다.                              |
| **504**       | 서버 오류(5xx)   | Gateway Timeout                                  | 서버가 게이트웨이로 동작할 때, 상위 서버가 응답하지 않아 타임아웃이 발생했음을 의미합니다.                    |



<br>
<br>

## TCP/IP

TCP/IP(Transmission Control Protocol/Internet Protocol)는 인터넷을 포함한 대부분의 네트워크에서 사용되는 **프로토콜 스택**으로, 데이터가 네트워크를 통해 전송되는 방식을 정의합니다. TCP/IP는 인터넷의 기본 구조를 형성하며, 컴퓨터가 서로 통신할 수 있도록 하는 표준 프로토콜입니다.

### **1. TCP/IP 모델의 계층 구조**

TCP/IP 모델은 OSI(Open Systems Interconnection) 모델과 유사하지만, 더 실용적인 네 개의 계층으로 구성됩니다. 각 계층은 특정 기능을 담당하며, 상위 계층이 하위 계층의 서비스를 이용하는 구조를 가지고 있습니다.

1. **네트워크 인터페이스 계층 (Network Interface Layer)**:
   - **역할**: 물리적 네트워크 연결 및 데이터 링크 계층 프로토콜을 다룹니다. 데이터가 실제 네트워크 하드웨어(예: 이더넷, Wi-Fi)를 통해 전송되는 것을 처리합니다.
   - **주요 프로토콜 및 기술**: 이더넷(Ethernet), Wi-Fi, ARP(Address Resolution Protocol), MAC(Media Access Control).

2. **인터넷 계층 (Internet Layer)**:
   - **역할**: 데이터를 패킷 단위로 나누어 네트워크 간 라우팅을 처리합니다. IP 주소를 사용하여 데이터 패킷이 출발지에서 목적지까지 도달할 경로를 결정합니다.
   - **주요 프로토콜**: 
     - **IP (Internet Protocol)**: IP 주소를 사용하여 패킷을 목적지로 라우팅합니다.
       - **IPv4**: 32비트 주소체계를 사용하며, 일반적으로 점으로 구분된 4개의 10진수로 표현됩니다(예: 192.168.0.1).
       - **IPv6**: 128비트 주소체계를 사용하며, 16진수로 표현됩니다(예: 2001:0db8:85a3:0000:0000:8a2e:0370:7334).
     - **ICMP (Internet Control Message Protocol)**: 네트워크 오류 보고 및 진단에 사용됩니다(예: ping 명령어).
     - **ARP (Address Resolution Protocol)**: IP 주소를 물리적 MAC 주소로 변환합니다.

3. **전송 계층 (Transport Layer)**:
   - **역할**: 애플리케이션 계층 간의 데이터 전송을 관리하며, 데이터의 신뢰성, 흐름 제어, 오류 복구 등을 담당합니다.
   - **주요 프로토콜**:
     - **TCP (Transmission Control Protocol)**: 연결 지향형 프로토콜로, 신뢰성 있는 데이터 전송을 보장합니다. 데이터가 손실되면 재전송하며, 데이터 순서를 보장합니다.
     - **UDP (User Datagram Protocol)**: 비연결형 프로토콜로, 빠르고 간단한 데이터 전송을 제공합니다. 신뢰성을 보장하지 않으며, 주로 실시간 애플리케이션(예: 스트리밍, VoIP)에서 사용됩니다.

4. **응용 계층 (Application Layer)**:
   - **역할**: 사용자가 직접적으로 상호작용하는 네트워크 서비스와 프로토콜을 제공합니다. 애플리케이션 계층은 네트워크 데이터를 처리하고, 사용자에게 필요한 기능을 수행합니다.
   - **주요 프로토콜**:
     - **HTTP/HTTPS (Hypertext Transfer Protocol/Secure)**: 웹 페이지의 전송을 처리합니다.
     - **FTP (File Transfer Protocol)**: 파일 전송을 위한 프로토콜입니다.
     - **SMTP (Simple Mail Transfer Protocol)**: 이메일 전송에 사용됩니다.
     - **DNS (Domain Name System)**: 도메인 이름을 IP 주소로 변환합니다.


### **2. TCP/IP의 데이터 전송 과정**

데이터가 전송될 때 TCP/IP 스택은 여러 계층을 통해 데이터를 캡슐화하고, 각 계층에서 필요한 정보를 추가합니다.

1. **응용 계층**에서 사용자가 입력한 데이터가 생성됩니다. 예를 들어, 사용자가 웹 브라우저에서 URL을 입력하면 HTTP 요청이 생성됩니다.
  
2. **전송 계층**에서는 TCP 또는 UDP가 데이터를 세그먼트 또는 데이터그램으로 나누고, 필요한 헤더(예: 포트 번호)를 추가합니다. TCP는 데이터의 신뢰성과 순서를 보장합니다.

3. **인터넷 계층**에서는 IP 패킷을 생성하고, IP 헤더를 추가합니다. 여기에는 출발지와 목적지의 IP 주소가 포함됩니다. 이 패킷은 네트워크를 통해 라우팅됩니다.

4. **네트워크 인터페이스 계층**에서는 패킷이 물리적 네트워크를 통해 전송될 수 있도록 프레임으로 캡슐화됩니다. MAC 주소와 같은 물리적 주소가 이 계층에서 사용됩니다.

5. **물리적 전송**: 네트워크를 통해 프레임이 목적지까지 전송됩니다.

6. **수신 측에서의 처리**: 각 계층은 데이터를 역캡슐화하여 상위 계층으로 전달합니다. 최종적으로 응용 계층에서 데이터가 사용자에게 전달됩니다.

### **3. TCP/IP의 활용 사례**

- **웹 브라우징**: 사용자가 웹 브라우저에서 URL을 입력하면, HTTP/HTTPS를 통해 웹 서버에 요청이 전송되고, 웹 페이지가 로드됩니다. 이 과정에서 TCP는 데이터의 신뢰성을 보장합니다.

- **이메일 전송**: 이메일 클라이언트는 SMTP를 사용하여 이메일을 전송합니다. 이 과정에서 TCP가 데이터의 손실 없이 전달되도록 합니다.

- **파일 전송**: FTP를 통해 파일을 전송할 때 TCP를 사용하여 파일이 손실 없이 전송되도록 합니다.

- **실시간 스트리밍**: UDP를 사용하여 비디오 스트리밍을 제공하며, 데이터 손실에 대한 복구가 필요 없는 경우 빠른 전송 속도를 제공합니다.



<br>
<br>


## gRPC와 REST API
**gRPC**와 **REST API**는 서로 다른 방식으로 통신하는 프로토콜입니다. 둘 다 서버와 클라이언트 간의 데이터 교환을 돕는 데 사용되지만, 그 작동 방식과 효율성, 적용 방식에서 차이점이 있습니다.

### **gRPC (Google Remote Procedure Call)**
- **통신 프로토콜**: HTTP/2 기반
- **데이터 포맷**: 바이너리 형식인 **Protocol Buffers (Protobuf)**를 사용하여 빠르고 효율적인 데이터 전송
- **성능**: HTTP/2의 스트리밍 및 다중화 기능 덕분에 성능이 뛰어남
- **타입 안정성**: Protobuf를 사용해 엄격한 타입 시스템을 제공, 코드 생성기(`.proto` 파일)를 통해 클라이언트와 서버에서 같은 스펙을 공유
- **양방향 스트리밍**: 서버와 클라이언트 간에 스트리밍이 가능, 실시간 통신에 적합
- **주로 사용되는 언어**: Go, Java, Python, Node.js 등 다양한 언어에서 사용 가능
- **RPC 호출 유형**:
  - Unary RPC: 클라이언트가 서버에 요청을 보내고 서버가 응답을 반환하는 기본적인 1:1 통신 방식입니다.
  - Server Streaming RPC: 클라이언트가 요청을 보내면 서버가 여러 개의 응답을 스트리밍 형태로 반환합니다.
  - Client Streaming RPC: 클라이언트가 여러 요청을 스트리밍 형태로 보내고 서버가 한 번의 응답을 반환합니다.
  - Bidirectional Streaming RPC: 클라이언트와 서버가 양방향으로 스트리밍 데이터를 주고받을 수 있습니다.

### **REST API (Representational State Transfer)**
- **통신 프로토콜**: HTTP/1.1 또는 HTTP/2 기반
- **데이터 포맷**: 주로 **JSON** 또는 **XML** 포맷을 사용하여 데이터를 주고받음
- **성능**: HTTP/1.1의 경우 요청마다 새 연결을 설정하는 오버헤드가 있을 수 있음. HTTP/2는 이 문제를 개선했으나, REST는 여전히 텍스트 기반이므로 gRPC보다 더 많은 데이터 전송량을 가질 수 있음.
- **타입 안정성**: 동적 타입을 사용하며, 스키마 정의 없이 데이터 구조를 유연하게 변경할 수 있음
- **주로 사용되는 언어**: JavaScript, Python, Java, PHP 등 대부분의 웹 언어에서 쉽게 구현 가능

### **차이점 요약**

| **특징**               | **gRPC**                        | **REST API**                  |
|------------------------|---------------------------------|-------------------------------|
| **통신 방식**          | HTTP/2 (바이너리 스트리밍)      | HTTP/1.1, HTTP/2 (텍스트 기반)|
| **데이터 형식**         | Protocol Buffers (Protobuf, 바이너리) | JSON 또는 XML (텍스트 기반)   |
| **성능**               | 빠르고 효율적, 압축된 바이너리 포맷 | 텍스트 기반이라 상대적으로 느림 |
| **타입 안전성**        | 엄격한 타입 시스템 (Protobuf)    | 유연한 동적 타입 (JSON)       |
| **코드 생성**          | 코드 생성기를 통해 클라이언트 및 서버 자동화 가능 | 수동 정의 필요                 |
| **양방향 스트리밍**    | 지원 (서버-클라이언트 양방향)    | 미지원 (단일 요청-응답)       |
| **사용 사례**          | 실시간 통신, 고성능 서비스      | 웹 서비스, 표준 HTTP API      |


**gRPC**: 
서버와 클라이언트 간의 **양방향 스트리밍**이 가능하여, 클라이언트는 제품 가격 변화 등을 실시간으로 서버로부터 스트리밍할 수 있습니다.

**REST API**: 
REST는 **단방향** 요청-응답 모델이므로 실시간 스트리밍이 어려워 주기적으로 서버에 요청해야 합니다. 이를 보완하기 위해 **웹소켓**을 사용할 수 있지만, REST 자체로는 양방향 스트리밍이 지원되지 않습니다.


<br>
<br>

