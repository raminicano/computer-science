# Database
데이터베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작된다. 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉 디스크 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 따라 결정된다고 볼 수 있다.
그렇기에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다. 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

## Index
데이터베이스에서 인덱스(Index)는 데이터 검색 속도를 높이기 위해 사용하는 데이터 구조입니다. 인덱스는 테이블의 한 열 또는 여러 열을 기반으로 하여, 특정 데이터를 빠르게 조회할 수 있도록 돕습니다. 인덱스를 사용하면 데이터베이스가 전체 테이블을 스캔하지 않고도 원하는 데이터를 효율적으로 찾을 수 있습니다. 인덱스는 데이터베이스 성능 최적화에서 중요한 역할을 합니다.

### **1. 인덱스의 개념**

- **인덱스의 역할**:
  - 인덱스는 책의 목차처럼, 특정 열의 값을 기준으로 데이터의 위치를 미리 저장해 두고, 검색 시 이 위치 정보를 활용하여 빠르게 데이터에 접근할 수 있도록 도와줍니다.
  - 인덱스를 사용하지 않으면, 데이터베이스는 필요한 데이터를 찾기 위해 테이블의 모든 행을 하나씩 검사해야 합니다(이것을 **풀 테이블 스캔**이라고 합니다).

- **인덱스의 구조**:
  - 인덱스는 보통 **B-트리**(B-Tree) 또는 그 변형인 **B+트리**(B+Tree) 구조로 구현됩니다. 이 구조는 트리 형태로 데이터를 정렬하여, 특정 값을 검색할 때 O(log n) 시간 복잡도로 데이터를 찾을 수 있게 합니다.
  - **해시 인덱스**: 해시 테이블(Hash Table)을 기반으로 한 인덱스도 존재합니다. 해시 인덱스는 특정 키 값을 기준으로 해시 함수를 사용해 데이터를 저장하고 검색합니다. 해시 인덱스는 정확한 값 검색에 매우 빠르지만, 범위 검색에는 적합하지 않습니다. 시간복잡도는 O(1)의 성능을 보이나 rehashing에 대한 부담이 있습니다.

### **2. 인덱스의 종류**

인덱스에는 여러 가지 종류가 있으며, 각기 다른 용도로 사용됩니다.

- **기본(primary) 인덱스**:
  - 테이블의 기본 키(Primary Key)에 자동으로 생성되는 인덱스입니다. 기본 인덱스는 테이블의 각 행을 고유하게 식별할 수 있도록 도와줍니다.

- **보조(secondary) 인덱스**:
  - 기본 키 외의 다른 열에 대해 생성하는 인덱스입니다. 보조 인덱스는 기본 키가 아닌 열을 기준으로 데이터를 빠르게 조회할 수 있게 합니다.

- **클러스터드 인덱스(Clustered Index)**:
  - 클러스터드 인덱스는 테이블의 데이터가 인덱스에 따라 물리적으로 정렬되어 저장되는 인덱스입니다. 한 테이블에는 하나의 클러스터드 인덱스만 있을 수 있습니다.
  - 클러스터드 인덱스가 있는 테이블의 경우, 데이터 자체가 인덱스의 일부이기 때문에 데이터를 검색할 때 매우 효율적입니다.

- **비클러스터드 인덱스(Non-clustered Index)**:
  - 비클러스터드 인덱스는 테이블의 데이터와는 별도로 저장되는 인덱스입니다. 비클러스터드 인덱스는 데이터를 정렬하지 않으며, 인덱스에 데이터의 참조만을 저장합니다.
  - 하나의 테이블에 여러 개의 비클러스터드 인덱스를 가질 수 있습니다.

- **복합(composite) 인덱스**:
  - 복합 인덱스는 두 개 이상의 열을 결합하여 만든 인덱스입니다. 복합 인덱스를 사용하면 여러 열을 동시에 조건으로 검색할 때 성능을 크게 향상시킬 수 있습니다.

- **고유(unique) 인덱스**:
  - 고유 인덱스는 인덱스가 적용된 열의 값이 중복되지 않도록 강제하는 인덱스입니다. 이는 기본 키와 유사하지만, 테이블의 다른 열에 대해서도 생성할 수 있습니다.

- **텍스트(Full-Text) 인덱스**:
  - 대용량 텍스트 데이터에 대해 효과적인 검색을 제공하는 인덱스입니다. 일반적으로 텍스트 검색 엔진에서 사용되며, 특정 키워드나 문구를 빠르게 검색할 수 있습니다.

### **3. 인덱스의 동작 원리**

- **인덱스 생성**:
  - 데이터베이스에서 인덱스를 생성하면, 인덱스는 지정된 열의 값들을 기반으로 트리 구조를 만듭니다. 이 트리 구조에는 각 값에 대한 참조(ROWID)가 포함되어 있으며, 이를 통해 데이터베이스는 특정 값을 빠르게 찾을 수 있습니다.

- **데이터 조회 시 인덱스 활용**:
  - 데이터베이스가 데이터를 조회할 때, 인덱스가 있으면 인덱스를 먼저 검색합니다. 검색된 인덱스는 해당 데이터의 위치를 반환하며, 데이터베이스는 해당 위치로 이동하여 데이터를 읽어옵니다. 이 과정을 통해 전체 테이블을 스캔하는 것보다 훨씬 빠르게 데이터를 찾을 수 있습니다.
  - 이때 선택되는 인덱스는 데이터베이스에 있는 optimizer가 자동으로 선택해줍니다. 선택된 인덱스를 확인하고 싶다면 `EXPLAIN`을 통해 확인할 수 있습니다. 사용자는 쿼리를 보낼 때 사용할 인덱스를 명시적으로 지정해줄 수 있습니다.

- **인덱스의 유지보수**:
  - 인덱스는 데이터를 삽입, 삭제, 수정할 때마다 자동으로 업데이트됩니다. 데이터베이스는 이러한 작업이 발생할 때마다 인덱스를 재조정하여 트리 구조를 유지합니다. 이는 성능에 약간의 부담을 줄 수 있지만, 일반적으로 조회 속도의 향상이 훨씬 큽니다.

### **4. 인덱스의 장단점**

**장점**:
- **빠른 검색**: 인덱스를 사용하면 데이터베이스가 특정 데이터를 매우 빠르게 검색할 수 있습니다. 인덱스는 전체 테이블을 스캔하는 대신, 효율적인 검색을 가능하게 합니다.
- **성능 최적화**: 특히 대규모 데이터베이스에서 인덱스는 검색 성능을 최적화하는 중요한 역할을 합니다.

**단점**:
- **추가 저장 공간 필요**: 인덱스는 데이터와 별도로 저장되기 때문에 추가적인 저장 공간을 필요로 합니다.
- **쓰기 작업에서의 성능 저하**: 데이터를 삽입, 삭제, 수정할 때마다 인덱스도 갱신되어야 하므로, 쓰기 작업이 느려질 수 있습니다.
- **잘못된 인덱스 사용**: 모든 열에 인덱스를 생성하는 것은 성능을 오히려 저하시킬 수 있습니다. 인덱스가 불필요하게 많아지면, 데이터베이스는 인덱스 관리에 과도한 리소스를 사용하게 됩니다.

### **5. 인덱스 설계 시 고려사항**

- **자주 조회되는 열에 인덱스 생성**: 자주 검색되거나 정렬에 사용되는 열에 인덱스를 생성하면 성능이 크게 향상됩니다.
- **쓰기 작업이 많은 경우 인덱스 최적화**: 쓰기 작업이 많은 테이블의 경우, 인덱스의 수와 구조를 최적화하여 쓰기 성능에 미치는 영향을 최소화해야 합니다.
- **복합 인덱스 사용**: 복합 인덱스를 잘 설계하면 여러 열을 결합한 검색에서도 높은 성능을 발휘할 수 있습니다. 하지만 열의 순서와 쿼리 패턴을 잘 분석하여 설계하는 것이 중요합니다.
- **인덱스 모니터링**: 인덱스의 효과를 주기적으로 모니터링하고, 불필요한 인덱스는 제거하거나 구조를 조정하는 것이 필요합니다.

### **6. 인덱스 사용 예시**

**단일 열 인덱스 생성**:
```sql
CREATE INDEX idx_username ON users (username);
```
- 이 예시는 `users` 테이블의 `username` 열에 인덱스를 생성하여, `username`을 기준으로 검색할 때 성능을 최적화합니다.

**복합 인덱스 생성**:
```sql
CREATE INDEX idx_name_email ON users (last_name, first_name);
```
- 이 예시는 `last_name`과 `first_name` 열을 결합한 복합 인덱스를 생성하여, 두 열을 기준으로 검색할 때 성능을 향상시킵니다.

**인덱스 사용 예시 쿼리**:
```sql
SELECT * FROM users WHERE username = 'john_doe';
```
- 이 쿼리는 `username` 열에 인덱스가 있는 경우, 인덱스를 사용하여 빠르게 데이터를 검색합니다.

### Full scan이 더 좋은 경우
- table에 데이터가 조금(몇 십, 몇백건) 있을 때
- 조회하려는 데이터가 테이블의 상당 부분을 차지할 때
- 이미 데이터가 몇 백만건 이상 있는 테이블에 인덱스를 생성하려는 경우 시간이 몇 분 이상 소요될 수 있고 DB에 안좋은 영향을 줄 수 있음



<br>
<br>

## 정규화

정규화(Normalization)는 데이터베이스 설계에서 데이터 중복을 줄이고, 데이터 무결성을 보장하기 위해 데이터를 구조화하는 과정입니다. 정규화를 통해 데이터베이스가 더 효율적이고 일관되게 동작하도록 설계할 수 있습니다. 정규화는 여러 단계로 나누어지며, 각 단계는 정규형(Normal Form)이라고 불립니다.

### **1. 정규화의 목적**

- **데이터 중복 제거**: 데이터를 중복해서 저장하지 않도록 하여, 저장 공간을 절약하고 데이터 불일치를 방지합니다.
- **데이터 무결성 유지**: 정규화를 통해 데이터베이스의 무결성을 유지하고, 삽입, 삭제, 갱신 시 발생할 수 있는 이상 현상(Anomalies)을 방지합니다.
  - 삽입 이상(insertion anomalies) 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말합니다.
  - 삭제 이상(deletion anomalies) 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말합니다.
  - 수정(갱신)이상(modification anomalies) 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말합니다.
- **데이터베이스의 효율성 향상**: 정규화를 통해 데이터 구조를 최적화하면, 쿼리 성능이 향상되고 데이터베이스 관리가 용이해집니다.

### **2. 정규형(Normal Form)의 단계**

정규화는 각 단계에서 특정 조건을 충족시키는 방식으로 이루어지며, 이를 통해 점진적으로 데이터 구조를 개선합니다. 주요 정규형에는 **1NF(제1정규형)**, **2NF(제2정규형)**, **3NF(제3정규형)**, 그리고 **BCNF(보이스-코드 정규형)** 등이 있습니다.

#### **1NF: 제1정규형 (First Normal Form)**

- **조건**: 모든 테이블의 필드는 원자 값(Atomic Value)이어야 합니다. 즉, 각 필드에는 하나의 값만 저장되어야 합니다.
- **설명**: 한 테이블의 열(컬럼)에는 더 이상 분해할 수 없는 단일 값만 있어야 하며, 중복된 열이 없어야 합니다.
- **예시**:
  - 비정규형: `과목` 필드에 여러 과목이 포함된 경우
    ```
    학생ID | 이름  | 과목
    --------|------|-----------------
    1       | 철수  | 수학, 과학, 영어
    2       | 영희  | 국어, 영어
    ```
  - 1NF로 변환: 각 과목을 별도의 행으로 분리
    ```
    학생ID | 이름  | 과목
    --------|------|-------
    1       | 철수  | 수학
    1       | 철수  | 과학
    1       | 철수  | 영어
    2       | 영희  | 국어
    2       | 영희  | 영어
    ```

#### **2NF: 제2정규형 (Second Normal Form)**

- **조건**: 제1정규형을 만족하며, 부분적 함수 종속성을 제거해야 합니다.
- **설명**: 테이블의 모든 비기본 속성이 기본 키에 대해 완전 함수 종속이어야 합니다. 부분 함수 종속은 제거합니다.
- **예시**:
  - 비정규형: 학생ID와 과목ID로 구성된 기본 키에 대해 학생 이름이 부분 종속된 경우
    ```
    학생ID | 과목ID | 이름  | 성적
    --------|--------|-------|-------
    1       | 101    | 철수  | A
    1       | 102    | 철수  | B
    2       | 101    | 영희  | B
    ```
  - 2NF로 변환: `이름` 필드를 별도의 테이블로 분리하여 학생ID에만 종속되도록 함
    - 학생 테이블:
      ```
      학생ID | 이름
      --------|------
      1       | 철수
      2       | 영희
      ```
    - 성적 테이블:
      ```
      학생ID | 과목ID | 성적
      --------|--------|-------
      1       | 101    | A
      1       | 102    | B
      2       | 101    | B
      ```

#### **3NF: 제3정규형 (Third Normal Form)**

- **조건**: 제2정규형을 만족하며, 이행적 함수 종속을 제거해야 합니다.
- **설명**: 어떤 비기본 속성이 다른 비기본 속성을 통해 기본 키에 종속되는 경우를 제거합니다. 즉, 기본 키가 아닌 속성들 간의 종속성을 제거합니다.
- **예시**:
  - 비정규형: 과목ID가 교사ID에 종속되고, 교사ID가 교사이름에 종속된 경우
    ```
    과목ID | 교사ID | 교사이름
    --------|--------|---------
    101    | T01    | 김선생님
    102    | T02    | 박선생님
    ```
  - 3NF로 변환: 교사 정보를 별도의 테이블로 분리
    - 과목 테이블:
      ```
      과목ID | 교사ID
      --------|--------
      101    | T01
      102    | T02
      ```
    - 교사 테이블:
      ```
      교사ID | 교사이름
      --------|---------
      T01    | 김선생님
      T02    | 박선생님
      ```

#### **BCNF: 보이스-코드 정규형 (Boyce-Codd Normal Form)**

- **조건**: 제3정규형을 만족하며, 모든 결정자가 후보 키여야 합니다.
- **설명**: 제3정규형을 강화한 형태로, 후보 키가 아닌 결정자가 존재할 경우 이를 분리하여 테이블을 재구성합니다.
- **예시**:
  - 비정규형: 특정 결정자가 후보 키가 아닌 경우
    ```
    과목ID | 강의실 | 시간
    --------|--------|--------
    101    | 201    | 10:00
    101    | 202    | 11:00
    102    | 201    | 11:00
    ```
  - BCNF로 변환: 강의실과 시간을 분리하여 테이블 재구성
    - 강의실 시간 테이블:
      ```
      강의실 | 시간
      --------|--------
      201    | 10:00
      202    | 11:00
      ```
    - 과목 테이블:
      ```
      과목ID | 강의실
      --------|--------
      101    | 201
      102    | 202
      ```

### **3. 정규화의 장단점**

**장점**:
- **데이터 중복 최소화**: 데이터를 정규화하면 중복된 데이터가 줄어들어 데이터 일관성이 유지됩니다.
- **데이터 무결성 보장**: 이상 현상(Anomalies)을 방지하여 데이터베이스의 무결성을 높입니다.
- **효율적인 데이터 저장**: 중복된 데이터를 제거하여 저장 공간을 절약할 수 있습니다.

**단점**:
- **복잡한 쿼리**: 테이블이 여러 개로 분리되기 때문에, 데이터를 조회할 때 조인을 사용해야 하며, 이는 쿼리를 복잡하게 만들 수 있습니다.
- **성능 저하**: 조인이 많아지면 쿼리 성능이 저하될 수 있습니다. 특히, 읽기 작업이 많은 시스템에서는 정규화를 통해 성능 저하가 발생할 수 있습니다.

### **4. 정규화의 비정규화(Denormalization)**

비정규화는 정규화된 데이터베이스에서 성능 향상을 위해 의도적으로 일부 중복을 허용하고 데이터를 통합하는 과정입니다. 이는 주로 읽기 성능을 최적화하기 위해 사용됩니다. 정규화와 비정규화 사이에서 적절한 균형을 찾는 것이 중요합니다.

**예시**:
- **정규화된 테이블**:
  - 고객 테이블과 주문 테이블이 분리되어 있으며, 조회 시 조인이 필요합니다.
- **비정규화된 테이블**:
  - 고객과 주문 정보를 하나의 테이블에 결합하여, 조인 없이 빠르게 데이터를 조회할 수 있습니다.

<br>
<br>

## Transaction

**트랜잭션(Transaction)**은 데이터베이스 관리 시스템(DBMS)에서 **데이터를 일관성 있게 처리하기 위한 작업의 단위**를 의미합니다. 트랜잭션은 데이터베이스의 상태를 변화시키는 여러 작업을 하나의 논리적 단위로 묶어 관리하며, 모든 작업이 성공적으로 완료되거나, 실패 시 모든 작업을 원래 상태로 되돌리는 것을 보장합니다. 이 과정에서 데이터의 일관성과 무결성을 유지하는 것이 트랜잭션의 핵심입니다.

### **1. 트랜잭션의 특성 (ACID)**

트랜잭션이 가지는 네 가지 중요한 특성은 **ACID**로 요약됩니다. 이는 트랜잭션이 데이터베이스에서 일관성을 유지하는 데 중요한 역할을 합니다.

- **Atomicity (원자성)**:
  - 트랜잭션 내의 모든 작업이 성공적으로 완료되거나, 전혀 수행되지 않은 것처럼 만드는 것을 보장합니다. 즉, 트랜잭션의 모든 연산이 성공적으로 수행되지 않으면, 모든 연산이 취소되고 데이터베이스는 트랜잭션이 시작되기 전의 상태로 복구됩니다.
  - 예시: 은행 계좌 간 이체에서, A 계좌에서 돈을 인출하고 B 계좌로 입금하는 두 연산이 하나의 트랜잭션으로 처리되며, 하나라도 실패하면 전체 트랜잭션이 롤백됩니다.

- **Consistency (일관성)**:
  - 트랜잭션이 완료되면, 데이터베이스는 일관성 있는 상태로 유지되어야 합니다. 트랜잭션이 성공적으로 완료되면 데이터베이스의 모든 무결성 제약 조건이 만족되어야 합니다.
  - 예시: 데이터베이스가 무결성 제약 조건을 가진다면, 트랜잭션 후에도 그 조건이 유지되어야 합니다.

- **Isolation (고립성)**:
  - 동시에 실행되는 여러 트랜잭션이 서로의 작업에 영향을 미치지 않도록 보장합니다. 각 트랜잭션은 독립적으로 수행되어야 하며, 다른 트랜잭션이 영향을 미치지 않도록 합니다.
  - 예시: 두 트랜잭션이 동일한 데이터를 읽고 쓰는 경우, 고립성은 한 트랜잭션이 완료될 때까지 다른 트랜잭션이 중간 상태의 데이터를 보지 못하게 합니다.

- **Durability (지속성)**:
  - 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 데이터베이스에 반영되어야 합니다. 시스템 장애가 발생하더라도 완료된 트랜잭션의 결과는 손실되지 않아야 합니다.
  - 예시: 트랜잭션이 커밋되면, 데이터베이스는 전원이 꺼지거나 시스템이 재시작되더라도 트랜잭션의 결과를 유지해야 합니다.

### **2. 트랜잭션의 상태**

![image](https://github.com/user-attachments/assets/fe7939ad-4ad3-4350-9d7e-a0723cfaa4cb)


트랜잭션은 수행 중 여러 상태를 가질 수 있습니다. 주요 트랜잭션 상태는 다음과 같습니다:

- **Active (활성 상태)**:
  - 트랜잭션이 시작되어 실행 중인 상태를 의미합니다. 이 상태에서는 트랜잭션이 실행 중이며, SQL 명령어를 수행하고 있습니다.

- **Partially Committed (부분 완료 상태)**:
  - 트랜잭션의 마지막 명령어가 실행된 직후의 상태를 의미합니다. 아직 모든 작업이 커밋되지 않았으며, 이 상태에서 오류가 발생하면 트랜잭션은 롤백됩니다.

- **Committed (완료 상태)**:
  - 트랜잭션이 성공적으로 완료되어 데이터베이스에 영구적으로 반영된 상태를 의미합니다. 트랜잭션이 커밋되면 변경 사항이 데이터베이스에 반영됩니다.

- **Failed (실패 상태)**:
  - 트랜잭션 중 오류가 발생하거나, 사용자가 명시적으로 트랜잭션을 중단한 경우의 상태입니다. 이 상태에서는 데이터베이스가 변경되지 않습니다.

- **Aborted (중단 상태)**:
  - 트랜잭션이 실패하여 이전 상태로 되돌아간 상태입니다. 중단된 트랜잭션은 데이터베이스에 어떤 영향도 남기지 않습니다.

### **3. 트랜잭션 제어 명령어**

트랜잭션을 제어하기 위해 SQL에서는 다음과 같은 명령어를 사용합니다:

- **BEGIN**:
  - 트랜잭션의 시작을 명시합니다. 트랜잭션 블록을 정의하고, 그 안의 모든 명령어가 하나의 트랜잭션으로 처리됩니다.

- **COMMIT**:
  - 트랜잭션을 성공적으로 완료하고, 트랜잭션 내의 모든 변경 사항을 데이터베이스에 영구적으로 반영합니다.

- **ROLLBACK**:
  - 트랜잭션 중 오류가 발생하거나 사용자가 중단을 명령할 경우, 트랜잭션 시작 이전의 상태로 되돌립니다. 이를 통해 트랜잭션이 부분적으로만 실행된 경우에도 데이터베이스의 일관성을 유지할 수 있습니다.

- **SAVEPOINT**:
  - 트랜잭션 내에서 롤백할 수 있는 지점을 설정합니다. 특정 시점까지의 변경 사항은 유지하면서 부분적으로 트랜잭션을 롤백할 수 있습니다.

- **ROLLBACK TO SAVEPOINT**:
  - 특정 SAVEPOINT로 트랜잭션을 롤백합니다. 이 명령을 사용하면 SAVEPOINT 이후의 모든 작업이 취소됩니다.


<br>
<br>

