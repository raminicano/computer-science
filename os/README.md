# os에 대해서


- [프로세스와 스레드](#프로세스와-스레드)
- [프로세스의 상태 PCB TCB 커널스레드 유저스레드](#프로세스의-상태-PCB-TCB-커널스레드-유저스레드)
- [스케쥴러](#스케쥴러)


<br>
<br>
<hr>


## 프로세스와 스레드

**프로세스**와 **스레드**는 운영체제에서 중요한 개념으로, 컴퓨터 시스템에서 작업을 수행하는 단위입니다. 두 개념은 작업을 나누고 실행하는 방식에서 차이가 있습니다. **프로세스**는 운영체제에서 독립된 실행 단위이고, **스레드**는 프로세스 내에서 작업을 실행하는 더 작은 실행 단위입니다.

### **1. 프로세스(Process)란?**

<img width="330" alt="image" src="https://github.com/user-attachments/assets/4fc9ebc6-c0ec-4f85-a025-21effccde1c4">


**프로세스**는 운영체제에서 **실행 중인 프로그램**을 의미합니다. 각각의 프로세스는 **자체의 메모리 공간과 시스템 자원**을 할당받아 독립적으로 실행됩니다.

- **메모리**: 프로세스는 독립적인 메모리 공간을 가집니다. 코드, 데이터, 스택, 힙 등으로 분리된 메모리 영역이 할당됩니다.
- **보호된 환경**: 각 프로세스는 **독립적**이므로, 한 프로세스가 다른 프로세스의 메모리나 자원에 직접 접근할 수 없습니다. 따라서 프로세스 간 통신(IPC, Inter-Process Communication)은 운영체제를 통해 이루어집니다.
- **문맥 교환**: 여러 프로세스가 동시에 실행되는 환경에서는 운영체제가 각 프로세스 사이에서 **문맥 교환(Context Switching)**을 수행합니다. 문맥 교환은 CPU가 하나의 프로세스에서 다른 프로세스로 전환될 때의 작업입니다. 이때, 이전 프로세스의 상태를 저장하고, 새로 실행할 프로세스의 상태를 복원하는 과정에서 오버헤드가 발생할 수 있습니다.

**프로세스의 예시**:
- 사용자가 실행한 웹 브라우저나 텍스트 편집기, 백그라운드에서 실행 중인 시스템 프로세스 등이 모두 운영체제에서 각각의 독립된 프로세스로 실행됩니다.

### **2. 스레드(Thread)란?**

**스레드**는 **프로세스 내에서 실행되는 작업의 흐름**으로, 프로세스의 실행 단위를 더욱 세분화한 개념입니다. **한 프로세스는 여러 스레드**를 가질 수 있으며, 이들 스레드는 같은 메모리 공간을 공유합니다.

- **메모리 공유**: 같은 프로세스 내의 스레드들은 **코드, 데이터, 힙**을 공유합니다. 하지만 각 스레드는 **자신만의 스택과 레지스터**를 가지고 독립적으로 실행됩니다.
- **경량화**: 스레드는 같은 프로세스 내에서 **공유된 메모리 공간**을 사용하므로, 프로세스 간의 문맥 교환보다 훨씬 **빠르게** 전환할 수 있습니다.
- **병렬 처리**: 하나의 프로세스에서 여러 스레드를 생성하면, 여러 스레드가 병렬로 작업을 수행할 수 있습니다. 이는 다중 코어 CPU 환경에서 특히 유리합니다.

**스레드의 예시**:
- 웹 브라우저에서 여러 탭을 동시에 처리하거나, 게임에서 물리 연산과 렌더링 작업을 병렬로 처리하는 경우, 각각의 작업은 스레드로 나눠집니다.

### **3. 프로세스와 스레드의 차이점**

| **특징**               | **프로세스(Process)**                        | **스레드(Thread)**                         |
|------------------------|---------------------------------------------|--------------------------------------------|
| **메모리**             | 독립적인 메모리 공간을 가짐                 | 같은 프로세스 내에서 메모리(코드, 데이터, 힙)를 공유 |
| **문맥 교환**          | 문맥 교환 시 오버헤드가 큼                   | 스레드 간 문맥 교환은 빠름                 |
| **실행 단위**          | 독립적인 실행 단위                          | 프로세스 내의 경량 실행 단위               |
| **오류 영향**          | 한 프로세스가 종료되면 다른 프로세스에 영향 없음 | 한 스레드가 비정상 종료되면 같은 프로세스 내 다른 스레드에 영향 가능 |
| **통신**               | IPC(프로세스 간 통신)를 통해서만 가능         | 같은 프로세스 내에서는 직접 메모리 접근 가능 |
| **사용 사례**          | 독립된 프로그램 실행                        | 병렬 작업 처리, 다중 작업 처리             |

### **4. 프로세스와 스레드의 장단점**

#### **프로세스의 장점**:
- **안정성**: 프로세스는 서로 독립적이기 때문에, 하나의 프로세스가 오류를 일으키더라도 다른 프로세스에 영향을 주지 않습니다.
- **보안성**: 각 프로세스는 별도의 메모리 공간을 가지고 있어, 메모리 침범이 어렵습니다.

#### **프로세스의 단점**:
- **비용**: 프로세스 간 문맥 교환이 빈번하게 일어나면 성능 저하가 발생할 수 있습니다.
- **통신 비용**: 서로 다른 프로세스 간의 데이터 공유나 통신은 IPC 메커니즘을 통해 이루어져야 하므로, 성능 오버헤드가 큽니다.

#### **스레드의 장점**:
- **성능**: 스레드는 같은 프로세스 내에서 메모리를 공유하므로, 문맥 교환이 프로세스 간 교환보다 빠릅니다.
- **메모리 절약**: 같은 프로세스의 자원을 공유하기 때문에, 여러 스레드가 생성되어도 메모리 사용량이 크게 증가하지 않습니다.

#### **스레드의 단점**:
- **안정성**: 한 스레드가 오류를 일으키면 같은 프로세스 내의 다른 스레드에도 영향을 미칠 수 있습니다.
- **복잡성**: 여러 스레드가 동시에 같은 자원에 접근할 때 **동기화 문제**(Race Condition, Deadlock 등)가 발생할 수 있어, 이를 처리하기 위한 추가적인 관리가 필요합니다.

### **5. 프로세스와 스레드의 사용 예시**

- **프로세스**: 웹 브라우저, 텍스트 에디터, 음악 재생 프로그램 등 독립적인 애플리케이션은 각각 하나의 프로세스로 실행됩니다.
- **스레드**: 웹 브라우저의 각 탭, 게임의 물리 엔진과 그래픽 처리, 웹 서버의 다중 클라이언트 요청 처리 등이 각각 스레드로 처리되어 병렬 작업이 가능합니다.

### **결론**

**프로세스**는 운영체제에서 독립적으로 실행되는 프로그램으로, 각자 고유한 메모리와 시스템 자원을 가지며, 서로 간섭하지 않고 안정적으로 실행됩니다. 반면에 **스레드**는 같은 프로세스 내에서 여러 작업을 병렬로 처리할 수 있는 경량화된 실행 단위로, 메모리를 공유하며 보다 빠르게 작업을 수행할 수 있지만, 동기화 문제에 주의해야 합니다.



<br>
<br>
<br>
<hr>

## 프로세스의 상태 PCB TCB 커널스레드 유저스레드

### **1. 프로세스의 상태 (Process States)**
![image](https://github.com/user-attachments/assets/f23904c7-6662-4cac-9c03-6ef3cbc779c6)

프로세스는 실행되는 동안 여러 상태를 거칩니다. 일반적으로 프로세스는 다음과 같은 주요 상태를 가집니다:

- **New(생성)**: 프로세스가 막 생성되어 실행을 준비하는 단계입니다. 아직 메모리에 올라가거나 실행되지는 않은 상태입니다.
  
- **Ready(준비)**: 프로세스가 실행될 준비가 완료된 상태입니다. CPU에서 실행되기를 기다리고 있으며, 실행 가능한 상태입니다. 그러나 CPU 할당을 받지 못한 상태입니다.
  
- **Running(실행 중)**: 프로세스가 CPU에서 실행되고 있는 상태입니다. Ready 상태에 있던 프로세스가 CPU를 할당받아 실행되면 Running 상태로 전환됩니다.

- **Blocked(대기)**: 프로세스가 **입출력(I/O) 작업**과 같은 외부 자원을 기다리고 있는 상태입니다. CPU는 사용하지 않으며, 자원이 준비될 때까지 대기 상태에 있습니다.

- **Terminated(종료)**: 프로세스가 **완료되거나 종료된** 상태입니다. 프로세스가 정상적으로 완료되거나 오류로 인해 종료되면 이 상태로 진입합니다.

- **Suspended(중지)**: 프로세스가 **메모리에서 완전히 내려간 상태**입니다. 주로 시스템 자원이 부족할 때 사용되며, 다시 실행되려면 메모리에 다시 올라가야 합니다.

이러한 상태들은 운영체제가 프로세스를 관리하기 위한 기본적인 상태 변화를 나타내며, **문맥 교환(Context Switching)** 과정에서 프로세스의 상태가 변경됩니다.

---

### **2. 프로세스 제어 블록 (PCB, Process Control Block)**

**PCB(Process Control Block)**는 운영체제가 프로세스를 관리하기 위해 사용하는 **데이터 구조**입니다. 프로세스에 대한 중요한 정보를 저장하고 있으며, **프로세스 상태 변화** 시 PCB를 참조하여 관리합니다. PCB는 다음과 같은 정보들을 포함합니다:

- **프로세스 상태**: 프로세스가 현재 어떤 상태에 있는지 나타냅니다(Ready, Running, Blocked 등).
- **프로세스 ID**: 운영체제가 프로세스를 식별하기 위해 부여하는 고유 ID.
- **레지스터 정보**: 프로세스가 CPU에서 실행되던 시점의 레지스터 값들을 저장합니다.
- **프로세스 우선순위**: 프로세스가 CPU를 얼마나 자주, 얼마나 빨리 할당받을지를 결정하는 우선순위 값.
- **프로그램 카운터**: 프로세스가 실행 중이던 마지막 명령어의 주소를 저장합니다.
- **메모리 관리 정보**: 프로세스에 할당된 메모리 정보(스택, 힙, 데이터 영역 등).
- **입출력 상태 정보**: 프로세스와 관련된 입출력 장치 상태 정보.

운영체제는 PCB를 기반으로 각 프로세스를 관리하며, 문맥 교환이 일어날 때 PCB에 저장된 정보가 CPU에 다시 로드됩니다.

---

### **3. 스레드 제어 블록 (TCB, Thread Control Block)**

**TCB(Thread Control Block)**는 **스레드의 정보를 관리하는 데이터 구조**입니다. 스레드 역시 프로세스와 유사하게 제어되어야 하기 때문에 운영체제는 각 스레드의 상태를 관리합니다. TCB는 다음과 같은 정보를 포함합니다:

- **스레드 ID**: 스레드를 구분하기 위한 고유 식별자.
- **스레드 상태**: 스레드의 현재 상태(Ready, Running, Blocked 등).
- **프로그램 카운터**: 스레드가 실행 중이던 명령어 주소.
- **레지스터 정보**: 스레드 실행 시 사용한 레지스터 값.
- **스레드 우선순위**: 스레드의 실행 우선순위를 나타내는 값.

TCB는 스레드가 여러 개 있는 환경에서 각 스레드의 실행 상태를 관리하고, 문맥 교환 시 각 스레드의 상태를 저장하고 복구하는 역할을 합니다.

---

### **4. 커널 스레드 (Kernel Thread)**

**커널 스레드**는 **운영체제가 직접 관리하는 스레드**로, 커널 모드에서 실행됩니다. 커널 스레드는 **운영체제 내에서 실행되는 스레드**이기 때문에 운영체제가 모든 것을 제어하며, 스레드의 생성, 스케줄링, 종료 등이 **커널에 의해 관리**됩니다.

- **장점**: 커널이 스레드를 직접 관리하므로, 여러 스레드가 동시에 CPU를 사용할 수 있으며, 멀티코어 환경에서 병렬 처리가 가능합니다.
- **단점**: 커널에서 직접 스레드를 관리하므로, **문맥 교환 비용**이 높고, 스레드 생성 및 관리에 대한 오버헤드가 큽니다.

**예시**: 대부분의 운영체제에서 사용하는 기본적인 스레드 관리 방식입니다. Windows, Linux 등에서 커널 스레드를 지원하며, 스레드의 동작을 최적화합니다.

---

### **5. 유저 스레드 (User Thread)**

**유저 스레드**는 **사용자 레벨에서 관리되는 스레드**로, 운영체제가 아닌 사용자 수준의 라이브러리에서 스레드를 관리합니다. 커널은 유저 스레드의 존재를 인식하지 못하며, 하나의 유저 스레드는 하나의 커널 스레드와 연결되지 않을 수 있습니다.

- **장점**: 문맥 교환이 **커널의 개입 없이 빠르게** 이루어지며, 스레드 생성과 관리에 드는 오버헤드가 적습니다.
- **단점**: 유저 스레드는 운영체제가 직접 관리하지 않기 때문에, **동시에 여러 스레드가 실행되지 못하는 경우**가 발생할 수 있습니다. 또한, 하나의 유저 스레드가 차단되면 전체 프로세스가 차단될 수 있습니다.

**예시**: `POSIX Threads (pthreads)`와 같은 라이브러리는 유저 스레드를 구현하는 대표적인 예입니다.

---

### **커널 스레드와 유저 스레드의 차이점**

| **특징**              | **커널 스레드(Kernel Thread)**               | **유저 스레드(User Thread)**                |
|-----------------------|----------------------------------------------|---------------------------------------------|
| **관리 주체**          | 운영체제가 직접 관리                         | 사용자 수준의 라이브러리에서 관리            |
| **문맥 교환 비용**     | 문맥 교환 비용이 높음                        | 문맥 교환 비용이 낮음                       |
| **동시성 지원**        | 멀티코어 환경에서 동시 실행 가능             | 동시 실행이 제한될 수 있음                   |
| **스레드 차단 시**     | 하나의 스레드가 차단되어도 다른 스레드는 실행 | 하나의 스레드가 차단되면 전체 프로세스 차단   |
| **스레드 생성 오버헤드**| 오버헤드가 큼                                | 오버헤드가 적음                              |

---

### 결론

- **프로세스 상태**는 프로세스가 실행되는 동안의 상태 변화를 나타내며, Ready, Running, Blocked 등으로 구분됩니다.
- **PCB**는 프로세스의 상태, 메모리 정보, 레지스터 값 등을 저장하는 데이터 구조로, 운영체제가 프로세스를 관리하는 데 중요한 역할을 합니다.
- **TCB**는 스레드의 상태와 정보를 관리하며, 스레드가 다중 작업을 수행할 때 중요한 역할을 합니다.
- **커널 스레드**는 운영체제가 직접 관리하는 스레드로, 병렬 처리가 가능하지만 문맥 교환 비용이 큽니다.
- **유저 스레드**는 사용자 레벨에서 관리되는 스레드로, 성능은 좋지만 운영체제와의 통합이 부족하여 한계가 있을 수 있습니다.

<br>
<br>
<br>
<hr>

## 스케쥴러


